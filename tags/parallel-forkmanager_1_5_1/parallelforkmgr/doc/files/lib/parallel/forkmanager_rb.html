<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: forkmanager.rb</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>forkmanager.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/parallel/forkmanager.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Mar 04 11:05:02 -0500 2011</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1><a href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a> &#8212; A simple parallel processing fork manager.</h1>
<h2>Copyright (c) 2008 - 2011 Nathan Patwardhan</h2>
<p>
All rights reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Ruby itself.
</p>
<h2>Author: Nathan Patwardhan &lt;noopy.org@gmail.com&gt;</h2>
<h2>Documentation</h2>
<p>
Nathan Patwardhan &lt;noopy.org@gmail.com&gt;, based on Perl <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
documentation by Noah Robin &lt;sitz@onastick.net&gt; and dLux
&lt;dlux@dlux.hu&gt;.
</p>
<h2>Credits (for original Perl implementation):</h2>
<ul>
<li>dLux &lt;dlux@dlux.hu&gt; (original Perl module)

</li>
<li>Chuck Hirstius &lt;chirstius@megapathdsl.net&gt; (callback exit status,
original Perl example)

</li>
<li>Grant Hopwood &lt;hopwoodg@valero.com&gt; (win32 port)

</li>
<li>Mark Southern &lt;mark_southern@merck.com&gt; (bugfix)

</li>
<li>Ken Clarke &lt;<a
href="http://www.perlprogrammer.net">www.perlprogrammer.net</a>&gt; (data
structure retrieval)

</li>
</ul>
<h2>Credits (Ruby port):</h2>
<ul>
<li>Robert Klemme &lt;shortcutter@googlemail.com&gt;, David A. Black
&lt;dblack@rubypal.com&gt; (general awesomeness)

</li>
<li>Roger Pack &lt;rogerdpack@gmail.com&gt; (bugfix, fork semantics in start,
doc changes)

</li>
<li>Mike Stok &lt;mike@stok.ca&gt; (test cases, percussion, backing vocals)

</li>
</ul>
<h2>Overview</h2>
<p>
<a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
is used for operations that you would like to do in parallel (e.g.
downloading a bunch of web content simultaneously) but uses fork() to
handle parallel processing instead of threads. If you&#8216;ve used fork()
before, you&#8216;re aware that you need to be responsible for managing
(i.e. cleaning up) the processes that were created as a result. <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
handles this for you such that you start() and finish() without having to
worry about child processes along the way. Further, <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
provides useful callbacks that you can use when a child starts and/or
finishes &#8212; or while you&#8216;re waiting for a child to complete.
</p>
<p>
The code for a downloader that uses Net::HTTP would look like this:
</p>
<pre>
 require 'rubygems'
 require 'net/http'
 require 'forkmanager'

 my_urls = [
     'url1',
     'url2',
     'urlN'
 ]

 max_proc = 30
 my_timeout = 5

 pm = Parallel::ForkManager.new(max_proc)

 my_urls.each {
     |my_url|

     pm.start(my_url) and next # blocks until new fork slot is available

     # doing stuff here with my_url will be in a child
     url = URI.parse(my_url)

     begin
         http = Net::HTTP.new(url.host, url.port)
         http.open_timeout = http.read_timeout = my_timeout
         res = http.get(url.path)

         status = res.code
         if status.to_i != 200
             print &quot;Cannot get #{url.path} from #{url.host}!\n&quot;
             pm.finish(255)
         else
             pm.finish(0)
         end
     rescue Timeout::Error, Errno::ECONNREFUSED =&gt; e
         print &quot;*** ERROR: #{my_url}: #{e.message}!\n&quot;
         pm.finish(255)
     end
 }

 pm.wait_all_children
</pre>
<p>
First you need to instantiate the ForkManager with the &quot;new&quot;
constructor. You must specify the maximum number of processes to be
created. If you specify 0, then NO fork will be done; this is good for
debugging purposes.
</p>
<p>
Next, use pm.start() to do the fork. pfm returns 0 for the child process,
and child pid for the parent process. The &quot;and next&quot; skips the
internal loop in the parent process.
</p>
<ul>
<li>pm.start() dies if the fork fails.

</li>
<li>pm.finish() terminates the child process (assuming a fork was done in the
&quot;start&quot;).

</li>
<li>You cannot use pm.start() if you are already in the child process. If you
want to manage another set of subprocesses in the child process, you must
instantiate another <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
object!

</li>
</ul>
<h2>Revision History</h2>
<ul>
<li>1.5.1, 2011-03-04: Resolves bug [29043] wait_one_child failed to retrieve
object. Adds conversion of Object to Hash before serialization to avoid
&#8216;singleton can&#8216;t be dumped&#8217; error. Minor documentation
changes for initialize().

</li>
<li>1.5.0, 2011-02-25: Implements data structure retrieval as had appeared in
Perl <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
0.7.6. Removes support for passing Proc to run_on_* methods; now supports
blocks instead. Documentation updates and code cleanup.

</li>
<li>1.2.0, 2010-02-01: Resolves bug [27748] finish throws an error when used
with start(ident). Adds block support to run_on_start(), run_on_wait(),
run_on_finish().

</li>
<li>1.1.1, 2010-01-05: Resolves bug with Errno::ECHILD.

</li>
<li>1.1.0, 2010-01-01: Resolves bug [27661] forkmanager doesn&#8216;t fork!.
Adds block support to start() w/doc changes for same.

</li>
<li>1.0.1, 2009-10-24: Resolves bug [27328] dies with max procs 1.

</li>
<li>1.0.0, 2008-11-03: Initial release.

</li>
</ul>
<h2>Bugs and Limitations</h2>
<p>
<a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
is a Ruby port of Perl <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
0.7.9. It was originally ported from Perl <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
0.7.5 but was recently updated to integrate features implemented in Perl <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
versions 0.7.6 - 0.7.9. Bug reports and feature requests are always
welcome.
</p>
<p>
Do not use <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
in an environment where other child processes can affect the run of the
main program, so using this module is not recommended in an environment
where fork() / wait() is already used.
</p>
<p>
If you want to use more than one copy of the <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
then you have to make sure that all children processes are terminated
&#8212; before you use the second object in the main program.
</p>
<p>
You are free to use a new copy of <a
href="../../../classes/Parallel/ForkManager.html">Parallel::ForkManager</a>
in the child processes, although I don&#8216;t think it makes sense.
</p>
<h2>Examples</h2>
<h3>Callbacks</h3>
<p>
Example of a program using callbacks to get child exit codes:
</p>
<pre>
 require 'rubygems'
 require 'forkmanager'

 max_procs = 5
 names = %w{ Fred Jim Lily Steve Jessica Bob Dave Christine Rico Sara }

 pm = Parallel::ForkManager.new(max_procs)

 # Setup a callback for when a child finishes up so we can get it's exit code
 pm.run_on_finish {
     |pid,exit_code,ident|
     print &quot;** #{ident} just got out of the pool with PID #{pid} and exit code: #{exit_code}\n&quot;
 }

 pm.run_on_start {
     |pid,ident|
     print &quot;** #{ident} started, pid: #{pid}\n&quot;
 }

 pm.run_on_wait(0.5) {
     print &quot;** Have to wait for one children ...\n&quot;
 }

 names.each_index {
     |child|
     pid = pm.start(names[child]) and next

     # This code is the child process
     print &quot;This is #{names[child]}, Child number #{child}\n&quot;
     sleep ( 2 * child )
     print &quot;#{names[child]}, Child #{child} is about to get out...\n&quot;
     sleep 1
     pm.finish(child) # pass an exit code to finish
 }

 print &quot;Waiting for Children...\n&quot;
 pm.wait_all_children
 print &quot;Everybody is out of the pool!\n&quot;
</pre>
<h3>Data structure retrieval</h3>
<p>
In this simple example, each child sends back a string.
</p>
<pre>
 require 'rubygems'
 require 'forkmanager'

 max_procs = 2
 persons = %w{Fred Wilma Ernie Bert Lucy Ethel Curly Moe Larry}

 pm = Parallel::ForkManager.new(max_procs, {'tempdir' =&gt; '/tmp'}, 0)

 # data structure retrieval and handling
 pm.run_on_finish { # called BEFORE the first call to start()
     |pid,exit_code,ident,exit_signal,core_dump,data_structure|

     # retrieve data structure from child
     if defined? data_structure # children are not forced to send anything
         str = data_structure # child passed a string
         print &quot;#{str}\n&quot;
     else  # problems occuring during storage or retrieval will throw a warning
         print &quot;No message received from child process #{pid}!\n&quot;
     end
 }

 # prep random statement components
 foods = ['chocolate', 'ice cream', 'peanut butter', 'pickles', 'pizza', 'bacon', 'pancakes', 'spaghetti', 'cookies']
 preferences = ['loves', 'can\'t stand', 'always wants more', 'will walk 100 miles for', 'only eats', 'would starve rather than eat']

 # run the parallel processes
 persons.each {
     |person|
     pm.start() and next

     # generate a random statement about food preferences
     pref_idx = preferences.index(preferences.sort_by{ rand }[0])
     food_idx = foods.index(foods.sort_by{ rand }[0])
     statement = &quot;#{person} #{preferences[pref_idx]} #{foods[food_idx]}&quot;

     # send it back to the parent process
     pm.finish(0, statement)
 }

 pm.wait_all_children
</pre>
<p>
A second data structure retrieval example demonstrates how children decide
whether or not to send anything back, what to send and how the parent
should process whatever is retrieved.
</p>
<pre>
 require 'rubygems'
 require 'forkmanager'

  max_procs = 20
  persons = %w{Fred Wilma Ernie Bert Lucy Ethel Curly Moe Larry}

  pm = Parallel::ForkManager.new(max_procs, {'tempdir' =&gt; '/tmp'}, 0)

  # data structure retrieval and handling
  retrieved_responses = {} # for collecting responses

  # data structure retrieval and handlin
  pm.run_on_finish { # called BEFORE the first call to start()
      |pid,exit_code,ident,exit_signal,core_dump,data_structure|

      # see what child sent us, if anything
      if defined? data_structure and !data_structure.empty? # test rather than assume child sent anything
          dsr = data_structure # child passed a string
          print &quot;#{ident} returned a #{dsr}.\n\n&quot;
          p dsr

          retrieved_responses[ident] = dsr
      else
          print &quot;#{ident} did not send anything.\n\n&quot;
      end
  }

  # generate a list of instructions
  instructions = [  # a unique identifier and what the child process should send
      {'name' =&gt; '%ENV keys as a string', 'send' =&gt; 'keys'},
      {'name' =&gt; 'Send Nothing'},  # not instructing the child to send anything back to the parent
      {'name' =&gt; 'Childs %ENV', 'send' =&gt; 'all'},
      {'name' =&gt; 'Child chooses randomly', 'send' =&gt; 'random'},
      {'name' =&gt; 'Invalid send instructions', 'send' =&gt; 'Na Na Nana Na'},
      {'name' =&gt; 'ENV values in an array', 'send' =&gt; 'values'},
  ]

  # prep random statement components
  foods = ['chocolate', 'ice cream', 'peanut butter', 'pickles', 'pizza', 'bacon', 'pancakes', 'spaghetti', 'cookies']
  preferences = ['loves', 'can\'t stand', 'always wants more', 'will walk 100 miles for', 'only eats', 'would starve rather than eat']

  # run the parallel processes
  instructions.each {
      |instruction|
      pm.start(instruction['name']) and next # this time we are using an explicit, unique child process identifier

      if !instruction.has_key?(&quot;send&quot;)
          print &quot;MT name #{instruction['name']}\n&quot;
          pm.finish(0)
      end

      if instruction['send'] == 'keys'
          pm.finish(0, ENV.keys())
      elsif instruction['send'] == 'values'
          pm.finish(0, ENV.values())
      elsif instruction['send'] == 'all'
          pm.finish(0, ENV)
      elsif instruction['send'] == 'random'
          str = &quot;I'm just a string.&quot;
          arr = %w{I am an array};
          hsh = {'type' =&gt; 'associative array', 'synonym' =&gt; 'hash', 'cool' =&gt; 'very :)'}
          choices = %w{str arr hsh}
          return_choice = choices.index(choices.sort_by{ rand }[0])

          if choices[return_choice] == 'str'
              pm.finish(0, str)
          elsif choices[return_choice] == 'arr'
              pm.finish(0, arr)
          elsif choices[return_choice] == 'hsh'
              pm.finish(0, hsh)
          end
      else
          pm.finish(0, &quot;Invalid instructions: #{instruction['send']}\n&quot;)
      end
  }

  pm.wait_all_children

  # post fork processing of returned data structures
  retrieved_responses.keys.sort.each {
      |response|
      print &quot;Post processing \&quot;#{response}\&quot;...\n&quot;
  }
</pre>

    </div>

    <div id="requires-list">
      <h3 class="section-bar">Required files</h3>

      <div class="name-list">
      tmpdir&nbsp;&nbsp;
      </div>
    </div>

   </div>


  </div>


    <!-- if includes -->
    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">
        <span class="include-name">Process</span>
      </div>
    </div>

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>